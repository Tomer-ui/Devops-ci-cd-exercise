// HEARTBEAT: Force-refreshing the Grand Machine state
pipeline {
    agent any

    options {
        buildDiscarder(logRotator(numToKeepStr: '10', artifactNumToKeepStr: '10'))
    } 

    triggers {
        githubPush()
    }
    
    environment {
        VENV = "${WORKSPACE}/venv"
        REPORTS_DIR = "${WORKSPACE}/reports"
        // Variables to track state for cleanup/logs
        CURRENT_IP = ""
        ENVIRONMENT = ""
    }
    
    stages {
        stage('Initialize') {
            when { 
                expression { 
                    return env.BRANCH_NAME == 'main' || env.GIT_BRANCH?.contains('main') || true 
                } 
            }
            steps {
                script {
                    echo "========================================"
                    echo "   THE GRAND MACHINE IS RUNNING V3.3    "
                    echo "========================================"
                    sh "mkdir -p ${REPORTS_DIR}"
                    def newVersion = sh(script: "python3 scripts/semver.py", returnStdout: true).trim()
                    env.BUILD_VERSION = newVersion
                    currentBuild.displayName = "#${env.BUILD_NUMBER} (${newVersion})"
                }
            }
        }
        
        stage('Setup Dependencies') {
            steps {
                sh '''
                    python3 -m venv ${VENV}
                    . ${VENV}/bin/activate
                    pip install --upgrade pip
                    pip install -r requirements.txt
                '''
            }
        }
        
        // ==========================================
        // STAGING PHASE
        // ==========================================
        
        stage('Staging: Provision') {
            steps {
                script {
                    env.ENVIRONMENT = "staging"
                    env.CURRENT_IP = provisionInfra("staging")
                    echo "Global IP set to: ${env.CURRENT_IP}"
                }
            }
        }

        stage('Staging: Configure') {
            steps {
                script { runAnsible(env.CURRENT_IP) }
            }
        }

        stage('Staging: Testing') {
            steps {
                script {
                    // This runs Unit -> Integration -> E2E
                    runTestSuite(env.CURRENT_IP, false)
                }
            }
            post {
                always {
                    script { harvestLogs(env.CURRENT_IP, "staging") }
                }
            }
        }

        // --- DEBUG GATEWAY (Comment this stage out later to automate) ---
        stage('Manual Approval / Debug') {
            steps {
                timeout(time: 1, unit: 'HOURS') {
                    input message: "Staging is ready at http://${env.CURRENT_IP}:5000. Logs available in Artifacts. Proceed to Production?", ok: "Proceed"
                }
            }
        }

        stage('Staging: Cleanup') {
            steps {
                script {
                    destroyInfra("staging")
                    env.CURRENT_IP = ""
                }
            }
        }

        // ==========================================
        // PRODUCTION PHASE
        // ==========================================

        stage('Production: Provision') {
            steps {
                script {
                    env.ENVIRONMENT = "prod"
                    env.CURRENT_IP = provisionInfra("prod")
                }
            }
        }

        stage('Production: Configure') {
            steps {
                script { runAnsible(env.CURRENT_IP) }
            }
        }

        stage('Production: Testing') {
            steps {
                script {
                    runTestSuite(env.CURRENT_IP, true) // Includes Performance Tests
                }
            }
            post {
                always {
                    script { harvestLogs(env.CURRENT_IP, "prod") }
                }
            }
        }
        
        stage('Build & Release') {
            steps {
                script {
                    withCredentials([usernamePassword(credentialsId: 'dockerhub-creds', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                        sh '''
                            echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin
                            docker build -t "$DOCKER_USER/devops-exercise:${BUILD_VERSION}" -f docker/Dockerfile .
                            docker push "$DOCKER_USER/devops-exercise:${BUILD_VERSION}"
                            docker tag "$DOCKER_USER/devops-exercise:${BUILD_VERSION}" "$DOCKER_USER/devops-exercise:latest"
                            docker push "$DOCKER_USER/devops-exercise:latest"
                        '''
                    }
                    
                    withCredentials([string(credentialsId: 'github-token', variable: 'GITHUB_TOKEN')]) {
                        sh '''
                            git config user.email "jenkins@tomas-pc"
                            git config user.name "Jenkins CI"
                            git remote set-url origin "https://${GITHUB_TOKEN}@github.com/Tomer-ui/Devops-ci-cd-exercise.git"
                            git push --delete origin "v${BUILD_VERSION}" || true
                            git tag -d "v${BUILD_VERSION}" || true
                            git tag -a "v${BUILD_VERSION}" -m "Release v${BUILD_VERSION}"
                            git push origin "v${BUILD_VERSION}"
                        '''

                        def jsonPayload = """
                            {
                              "tag_name": "v${env.BUILD_VERSION}",
                              "target_commitish": "main",
                              "name": "v${env.BUILD_VERSION}",
                              "body": "Automated release from Jenkins Build #${env.BUILD_NUMBER}",
                              "draft": false,
                              "prerelease": false
                            }
                        """
                        writeFile file: 'release.json', text: jsonPayload
                        sh '''
                            curl -X POST -H "Authorization: token ${GITHUB_TOKEN}" -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/Tomer-ui/Devops-ci-cd-exercise/releases -d @release.json
                        '''
                    }
                }
            }
        }

        stage('Production: Cleanup') {
            steps {
                script {
                    destroyInfra("prod")
                    env.CURRENT_IP = ""
                }
            }
        }
    } 

    post {
        always {
            script {
                // Archive and publish all HTML reports
                publishHTML([allowMissing: true, alwaysLinkToLastBuild: true, keepAll: true, reportDir: 'reports', reportFiles: 'unit_report.html', reportName: 'Unit Test Report'])
                publishHTML([allowMissing: true, alwaysLinkToLastBuild: true, keepAll: true, reportDir: 'reports', reportFiles: 'integration_report.html', reportName: 'Integration Test Report'])
                publishHTML([allowMissing: true, alwaysLinkToLastBuild: true, keepAll: true, reportDir: 'reports', reportFiles: 'e2e_report.html', reportName: 'E2E Test Report'])
                publishHTML([allowMissing: true, alwaysLinkToLastBuild: true, keepAll: true, reportDir: 'reports', reportFiles: 'performance_report.html', reportName: 'Performance Report'])
                publishHTML([allowMissing: true, alwaysLinkToLastBuild: true, keepAll: true, reportDir: 'htmlcov', reportFiles: 'index.html', reportName: 'Code Coverage Report'])
            }
        }
        failure {
            script {
                slackSend (color: '#FF0000', message: "❌ FAILURE: Build #${env.BUILD_NUMBER} failed on ${env.ENVIRONMENT} phase.")
                jiraNewIssue (
                    site: 'JiraLocal', 
                    issue: [
                        fields: [
                            project: [ key: 'DEV' ], 
                            summary: "Build Failure: DevOps-Exercise #${env.BUILD_NUMBER}", 
                            description: "Pipeline stopped. Check artifacts for remote_logs. Check build: ${env.JOB_URL}",
                            issuetype: [ name: 'Bug' ]
                        ]
                    ]
                )
            }
        }
        success {
            slackSend (color: '#00FF00', message: "✅ SUCCESS: Build #${env.BUILD_NUMBER} released to Production!")
        }
        cleanup {
            script {
                // Final safety cleanup if the pipeline crashed before stage cleanup
                if (env.ENVIRONMENT) { 
                    echo "Ensuring cleanup for environment: ${env.ENVIRONMENT}"
                    destroyInfra(env.ENVIRONMENT) 
                }
                sh "docker system prune -f"
                cleanWs()
            }
        }
    }
}

// --- HELPER FUNCTIONS ---

def provisionInfra(envName) {
    def capturedIP = ""
    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-credentials']]) {
        dir('terraform') {
            sh 'terraform init'
            echo "Attempting state reset for ${envName}..."
            sh "terraform destroy -var='environment=${envName}' -auto-approve || true"
            sh "terraform apply -var='environment=${envName}' -auto-approve"
            sh 'terraform refresh' 
            capturedIP = sh(script: "terraform output -raw instance_public_ip", returnStdout: true).trim()
        }
    }
    
    echo "DEBUG: Final IP being returned to Pipeline: [${capturedIP}]"
    
    if (!capturedIP || capturedIP == "null" || capturedIP == "" || capturedIP.contains("Error")) {
        error "CRITICAL: IP capture failed. Result was: '${capturedIP}'"
    }
    return capturedIP
}

def runAnsible(ip) {
    withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-ssh-key', keyFileVariable: 'SSH_KEY_PATH')]) {
        dir('ansible') {
            sh "echo '[app]\n${ip} ansible_user=ubuntu ansible_ssh_private_key_file=${SSH_KEY_PATH}' > inventory"
            sh "timeout 60s bash -c 'until nc -zv ${ip} 22; do sleep 5; done' || true"
            sh "ansible-playbook -i inventory setup.yml"
        }
    }
}

def harvestLogs(ip, envName) {
    if (ip) {
        echo "Scraping logs from ${envName} machine (${ip})..."
        try {
            withCredentials([sshUserPrivateKey(credentialsId: 'jenkins-ssh-key', keyFileVariable: 'SSH_KEY_PATH')]) {
                sh "ssh -i ${SSH_KEY_PATH} -o StrictHostKeyChecking=no ubuntu@${ip} 'journalctl -u flask-app --no-pager -n 200' > ${WORKSPACE}/${envName}_flask_logs.txt"
                archiveArtifacts artifacts: "${envName}_flask_logs.txt", allowEmptyArchive: true
            }
        } catch (e) {
            echo "Failed to harvest logs from ${envName}: ${e}"
        }
    }
}

def runUnitTests() {
    sh ". ${VENV}/bin/activate && pytest tests/unit --cov=app --html=${REPORTS_DIR}/unit_report.html --self-contained-html"
}

def runIntegrationTests() {
    sh ". ${VENV}/bin/activate && pytest tests/integration --html=${REPORTS_DIR}/integration_report.html --self-contained-html"
}

def runE2ETests(ip) {
    sh ". ${VENV}/bin/activate && export APP_URL='http://${ip}:5000' && pytest tests/e2e --html=${REPORTS_DIR}/e2e_report.html --self-contained-html"
}

def runTestSuite(ip, isProd) {
    // Fail-Fast: Any failure here stops the function immediately
    runUnitTests()
    runIntegrationTests()
    runE2ETests(ip)
    if (isProd) {
        sh ". ${VENV}/bin/activate && locust -f tests/performance/locustfile.py --headless --users 10 --spawn-rate 2 --run-time 30s --host http://${ip}:5000 --html ${REPORTS_DIR}/performance_report.html"
    }
}

def destroyInfra(envName) {
    withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'aws-credentials']]) {
        dir('terraform') {
            sh "terraform destroy -var='environment=${envName}' -auto-approve"
        }
    }
}
